## Global Docker image parameters
## Please, note that this will override the image parameters, including dependencies, configured to use the global value
## Current available global Docker image parameters: imageRegistry and imagePullSecrets
## NOTE: Global variables of parent charts take precedence over global variables in dependent charts.
##
# global:
#   imageRegistry: myRegistryName
#   imagePullSecrets:
#     - myRegistryKeySecretName
#   storageClass: myStorageClass

# Default values for djangohelm.
# Declare variables to be passed into your templates.
replicaCount: 1
image: djangoapp:0.2
# Will only search for local image in Minikube
pullPolicy: Never
# This is the helm convention on declaring images
# image:
#   repository: nginx
#   tag: stable
#   pullPolicy: IfNotPresent
service:
  type: NodePort
  name: djangoapp
  ## HTTP Port
  externalPort: 8000
  internalPort: 8000
  # TODO: Configure service according to best practise
  ## HTTPS Port
  # httpsPort: 443
  ## HTTPS Target Port
  ## defaults to https unless overridden to the specified port.
  ## if you want the target port to be "http" or "80" you can specify that here.
  # httpsTargetPort: https
  ## metrics Port
  # metricsPort: 9117
  ##
  ## nodePorts:
  ##   http: <to set explicitly, choose port between 30000-32767>
  ##   https: <to set explicitly, choose port between 30000-32767>
  ##   metrics: <to set explicitly, choose port between 30000-32767>
  # nodePorts:
  #   http: ""
  #   https: ""
  #   metrics: ""
  ## Enable client source IP preservation
  ## ref http://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
  ##
  # externalTrafficPolicy: Cluster
  # annotations: {}
  ## Extra ports to expose (normally used with the `sidecar` value)
  # extraPorts:

## Allow health checks to be pointed at the https port
# healthcheckHttps: false

## Configure extra options for liveness and readiness probes
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes)
# livenessProbe:
#   initialDelaySeconds: 120
#   periodSeconds: 10
#   timeoutSeconds: 5
#   failureThreshold: 6
#   successThreshold: 1
# readinessProbe:
#   initialDelaySeconds: 30
#   periodSeconds: 10
#   timeoutSeconds: 5
#   failureThreshold: 6
#   successThreshold: 1
## If using an HTTPS-terminating load-balancer, the probes may need to behave
## like the balancer to prevent HTTP 302 responses.  According to the Kubernetes
## docs, 302 should be considered "successful", but this issue on GitHub
## (https://github.com/kubernetes/kubernetes/issues/47893) shows that it isn't.
# livenessProbeHeaders:
# - name: X-Forwarded-Proto
#   value: https
# readinessProbeHeaders:
# - name: X-Forwarded-Proto
#   value: https

ingress:
  enabled: false
  # Used to create an Ingress record.
  hosts:
    - chart-example.local
  annotations:
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  tls:
    # Secrets must be manually created in the namespace.
    # - secretName: chart-example-tls
    #   hosts:
    #     - chart-example.local

resources: {}
  ## We usually recommend not to specify default resources and to leave this as a conscious
  ## choice for the user. This also increases chances charts run on environments with little
  ## resources, such as Minikube. If you do want to specify resources, uncomment the following
  ## lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #  cpu: 100m
  #  memory: 128Mi
  # requests:
  #  cpu: 100m
  #  memory: 128Mi

## PostgreSQL chart configuration
##
## https://github.com/helm/charts/tree/master/stable/postgresql
## https://engineering.bitnami.com/articles/create-a-production-ready-postgresql-cluster-bitnami-kubernetes-and-helm.html
##
## Whether to deploy a postgresql server to satisfy the applications database requirements.
## To use an external database set this to false and configure the externalDatabase parameters
# TODO: Implement postgresql credential settings
postgresql:
  # requirements condition
  enabled: false
  # image:
  #   registry: docker.io
  #   repository: bitnami/postgresql
  #   tag: 11.6.0-debian-9-r0
  # pullPolicy: IfNotPresent
  # pullSecrets:
  #   - myRegistryKeySecretName
  # debug: false
  # nameOverride:
  # fullnameOverride:
  # volumePermissions:
  #   enabled: true
  #   image:
  #     registry: docker.io
  #     repository: bitnami/minideb
  #     tag: stretch
  #   pullPolicy: Always
  #   pullSecrets:
  #     - myRegistryKeySecretName
  #   securityContext:
  #     runAsUser: 0
  # schedulerName:
  # securityContext:
  #   enabled: true
  #   fsGroup: 1001
  #   runAsUser: 1001
  # serviceAccount:
  #   enabled: false
  #   name:
  # replication:
  #   enabled: false
  #   user: repl_user
  #   password: repl_password
  #   slaveReplicas: 1
  #   synchronousCommit: "off"
  #   numSynchronousReplicas: 0
  #   applicationName: my_application
  # postgresqlPostgresPassword:
  postgresqlUsername: < leave as postgres for standard super user access >
  postgresqlPassword: < super_secret >
  # existingSecret: secret
  # usePasswordFile: false
  postgresqlDatabase: < djangoapp >
  postgresqlDataDir: < /path/to/your/project/postgresql/data >
  # postgresqlInitdbArgs:
  # postgresqlInitdbWalDir:
  # postgresqlConfiguration:
  # postgresqlExtendedConf:
  # pgHbaConfiguration:
  # configurationConfigMap:
  # extendedConfConfigMap:
  # initdbScripts:
  # initdbScriptsConfigMap:
  # initdbScriptsSecret:
  # initdbUser:
  # initdbPassword:
  # terminationGracePeriodSeconds: 30
  # ldap:
  #   enabled: false
  #   url: ""
  #   server: ""
  #   port: ""
  #   prefix: ""
  #   suffix: ""
  #   baseDN: ""
  #   bindDN: ""
  #   bind_password:
  #   search_attr: ""
  #   search_filter: ""
  #   scheme: ""
  #   tls: false
  service:
  #   type: ClusterIP
  #   clusterIP: None
    port: < leave as default port 5432 >
  #   nodePort:
  #   annotations: {}
  #   loadBalancerIP:
  #   loadBalancerSourceRanges:
  # persistence:
  #   enabled: true
  #   existingClaim:
  #   mountPath: /bitnami/postgresql
  #   subPath: ""
  #   storageClass: "-"
  #   accessModes:
  #     - ReadWriteOnce
  #   size: 8Gi
  #   annotations: {}
  # updateStrategy:
  #   type: RollingUpdate
  # master:
  #   nodeSelector: {}
  #   affinity: {}
  #   tolerations: []
  #   labels: {}
  #   annotations: {}
  #   podLabels: {}
  #   podAnnotations: {}
  #   extraInitContainers:
  # extraVolumeMounts: []
  #   extraVolumes: []
  # slave:
  #   nodeSelector: {}
  #   affinity: {}
  #   tolerations: []
  #   labels: {}
  #   annotations: {}
  #   podLabels: {}
  #   podAnnotations: {}
  #   extraInitContainers:
  #   extraVolumeMounts: []
  #   extraVolumes: []
  resources:
    requests:
      memory: < official recommendation is 1000Mi >
      cpu: < e.g. 1000m >
  # networkPolicy:
  #   enabled: false
  #   allowExternal: true
  # livenessProbe:
  #   enabled: true
  #   initialDelaySeconds: 30
  #   periodSeconds: 10
  #   timeoutSeconds: 5
  #   failureThreshold: 6
  #   successThreshold: 1
  # readinessProbe:
  #   enabled: true
  #   initialDelaySeconds: 5
  #   periodSeconds: 10
  #   timeoutSeconds: 5
  #   failureThreshold: 6
  #   successThreshold: 1
  # metrics:
  #   enabled: false
  #   resources: {}
  #   service:
  #     type: ClusterIP
  #     annotations:
  #       prometheus.io/scrape: "true"
  #       prometheus.io/port: "9187"
  #     loadBalancerIP:
  #   serviceMonitor:
  #     enabled: false
  #     additionalLabels: {}
  #     namespace: monitoring
  #     interval: 30s
  #     scrapeTimeout: 10s
  #   image:
  #     registry: docker.io
  #     repository: bitnami/postgres-exporter
  #     tag: 0.7.0-debian-9-r12
  #     pullPolicy: IfNotPresent
  #     pullSecrets:
  #       - myRegistryKeySecretName
  #   customMetrics:
  #     pg_database:
  #     query: "SELECT d.datname AS name, CASE WHEN pg_catalog.has_database_privilege(d.datname, 'CONNECT') THEN pg_catalog.pg_database_size(d.datname) ELSE 0 END AS size FROM pg_catalog.pg_database d where datname not in ('template0', 'template1', 'postgres')"
  #     metrics:
  #       - name:
  #           usage: "LABEL"
  #           description: "Name of the database"
  #       - size_bytes:
  #           usage: "GAUGE"
  #           description: "Size of the database in bytes"
  #   securityContext:
  #     enabled: false
  #     runAsUser: 1001
  #   livenessProbe:
  #     enabled: true
  #     initialDelaySeconds: 5
  #     periodSeconds: 10
  #     timeoutSeconds: 5
  #     failureThreshold: 6
  #     successThreshold: 1
  #   readinessProbe:
  #     enabled: true
  #     initialDelaySeconds: 5
  #     periodSeconds: 10
  #     timeoutSeconds: 5
  #     failureThreshold: 6
  #     successThreshold: 1
  #  extraEnv: []

